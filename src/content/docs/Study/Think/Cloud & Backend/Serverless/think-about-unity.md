---
title: About Unity...
sidebar:
  order: 30
---

## 1) Unity + C#에서 “서버리스”를 쓰는 대표 패턴_

### 패턴 A: Unity → HTTP API(서버리스 함수) → DB/외부 API
- 로그인 후 토큰(Firebase Auth, Cognito 등)을 받아서
- Unity가 함수(HTTP 엔드포인트)에 요청
- 함수가 DB 업데이트/검증 후 응답

**적합**
- 랭킹 등록, 출석체크, 쿠폰 검증, 결제 영수증 검증, 리더보드 집계

---

### 패턴 B: 이벤트 기반 처리 (DB/스토리지 변화에 반응)
- “유저 데이터 생성” → 함수 자동 실행 → 초기 보상 지급
- “스토리지에 파일 업로드” → 함수 실행 → 썸네일 생성/메타데이터 저장

**적합**
- 운영 자동화, 배치성 처리, 비동기 후처리(이미지/로그/통계)

---

## 2) Unity에서 서버리스 선택 기준 (실무 체크리스트)

### 서버리스(FaaS)가 잘 맞는 경우
- 요청이 들쑥날쑥(스파이크)하고 운영 부담을 줄이고 싶다
- 이벤트 기반 처리가 많다(유저 생성/업데이트/스토리지 업로드 등)
- “짧은 검증 로직”이 많다(쿠폰, 결제, 점수 제출, 권한 체크)

### 서버리스가 애매하거나 불리한 경우
- 실시간 전투/룸 서버처럼 **항상 떠 있어야 하는** 세션 서버
- 장시간 작업/무거운 상태ful 로직이 많은 서비스
- 매우 낮은 지연(latency)이 절대적으로 중요한 경로(콜드스타트/홉 증가)

### 대안 조합(현실적인 하이브리드)
- 실시간/세션 서버: IaaS 또는 CaaS(컨테이너)
- 검증/정산/이벤트 후처리: FaaS(서버리스 함수)
- 관리자 API/대시보드: PaaS 또는 CaaS

---

## 3) Unity 클라이언트 설계 팁 (서버리스 전제)

- **클라에서는 “결정”하지 말고 “요청”만 하게 설계**
  - 보상, 랭킹, 결제 승인 같은 핵심 로직은 서버(함수)에서 확정
- **재시도/타임아웃**을 기본 탑재
  - 모바일 네트워크 특성상 실패는 정상 케이스
- **아이템 멱등성(Idempotency)** 고려
  - “버튼 연타/재전송”에서 중복 지급/중복 반영 방지(서버에서 키로 방어)
- **로그/트레이싱 키**(requestId, userId, buildVersion) 포함
  - 장애 대응 때 Unity 로그와 서버 로그를 연결할 수 있게

---

## 4) 용어 빠른 요약

- **IaaS**: VM. 운영 자유도↑, 운영 부담↑
- **CaaS**: 컨테이너. 표준화된 배포/스케일, 학습 필요
- **PaaS**: 앱 서비스. 운영 부담↓, 제약 일부
- **FaaS**: 함수. 이벤트/요청 기반, 운영 최소, 제약(콜드스타트/시간/상태)

- **AWS Lambda**: AWS의 대표 FaaS
- **Google Cloud Functions**: GCP의 대표 FaaS
- **Firebase Functions**: Firebase 중심 이벤트/인증/DB 연동에 최적화된 FaaS

---